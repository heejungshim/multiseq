% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiseq.R
\name{compute.logLR}
\alias{compute.logLR}
\title{Compute logLR.}
\usage{
compute.logLR(x, g, TItable = NULL, read.depth = NULL, minobs = 1,
  pseudocounts = 0.5, all = FALSE, center = FALSE, repara = TRUE,
  forcebin = FALSE, lm.approx = TRUE, disp = "add", nullcheck = TRUE,
  pointmass = TRUE, prior = "uniform", gridmult = 2, mixsd = NULL,
  trace = FALSE, mixcompdist = "normal", lambda1 = 1, lambda2 = 0,
  df = NULL, randomstart = FALSE, minimaloutput = FALSE, maxiter = 5000,
  VB = FALSE, cxx = TRUE, maxlogLR = NULL)
}
\arguments{
\item{x:}{a matrix of \code{nsig} by \code{n} counts where \code{n} should be a power of 2}

\item{g:}{an \code{nsig}-vector containing group indicators/covariate value for each sample}

\item{TItable:}{pre-calculated \code{TItable}; If \code{TItable} is provided, this function skips computation of \code{TItable} from \code{x} and use the \code{TItable} provided as a parameter. This helps with fast permutation test.}

\item{read.depth:}{an \code{nsig}-vector containing the total number of reads for each sample (used to test for association with the total intensity). Defaults to NULL.}

\item{minobs:}{minimum number of obs required to be in each logistic model}

\item{pseudocounts:}{a number to be added to counts}

\item{all:}{bool, if TRUE pseudocounts are added to all entries, if FALSE pseudocounts are added only to cases when either number of successes or number of failures (but not both) is 0}

\item{center:}{bool, indicating whether to center \code{g}}

\item{repara:}{bool, indicating whether to reparameterize alpha and beta so that their likelihoods can be factorized.}

\item{forcebin:}{bool, if TRUE don't allow for overdipersion. Defaults to TRUE if \code{nsig=1}}

\item{lm.approx:}{bool, indicating whether a WLS alternative should be used}

\item{disp:}{"add" or "mult", indicates which type of overdispersion is assumed when \code{lm.approx}=TRUE}

\item{cxx:}{bool, indicating whether to use Rcode or c++ code (faster)}

\item{maxlogLR:}{a positive number, default=NULL, if \code{maxlogLR} is provided as a positive number, the function returns this number as \code{logLR} when \code{logLR} is infinite.}
}
\value{
a list of \code{logLR}, \code{logLR.each.scale}, \code{finite.logLR}; \code{logLR.each.scale} contains logLR for each scale. \code{finite.logLR} takes 0 or 1 indicating whether \code{logLR} is finite or not.
}
\description{
This function takes a series of Poisson count signals \code{x}, with data on different samples in each row and covariate \code{g} for each sample, and compute logLR to test for association between \code{x} and \code{g}. If \code{TItable} is provided, this function skips computation of \code{TItable} from \code{x} and use the \code{TItable} provided as a parameter. This helps with fast permutation test. Parameters \code{minobs}, \code{pseudocounts}, \code{all}, \code{center}, \code{repara}, \code{forcebin}, \code{lm.approx}, and \code{disp} are passed to \code{\link{glm.approx}}. The list \code{ashparam} specifies a list of parameters to be passed to \code{ash}.
}

