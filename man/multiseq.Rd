% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiseq.R
\name{multiseq}
\alias{multiseq}
\title{Estimate underlying signal from count data \code{x} and optionally the effect of a covariate \code{g}.}
\usage{
multiseq(x = NULL, g = NULL, read.depth = NULL, reflect = FALSE,
  baseline = "inter", minobs = 1, pseudocounts = 0.5, all = FALSE,
  center = FALSE, repara = TRUE, forcebin = FALSE, lm.approx = TRUE,
  disp = c("add", "mult"), overall.effect = TRUE, overall.loglr = FALSE,
  cxx = TRUE, smoothing = TRUE, cyclespin = TRUE, reverse = TRUE,
  maxlogLR = NULL, set.fitted.g = NULL, set.fitted.g.intercept = NULL,
  get.fitted.g = TRUE, listy = NULL, verbose = FALSE, ashparam = list())
}
\arguments{
\item{x:}{a matrix (or a vector) of \code{nsig} by \code{n} counts where \code{n} should be a power of 2 or a vector of size \code{n}.}

\item{read.depth:}{an \code{nsig}-dimensional vector containing the total number of reads for each sample (used to test for association with the total intensity); defaults to NULL.}

\item{reflect:}{bool, if TRUE signal is reflected, if FALSE signal is not reflected. Defaults to TRUE if n is not power of 2. See \code{\link{reflectSignal}} for details.}

\item{baseline:}{a string, can be "inter" or "grp" or a number. Uses intercept \code{g=0} as baseline ("inter") or the group with the smallest \code{g} as baseline ("grp") or specifies value of \code{g} that should be baseline (number). If center==FALSE and baseline=="inter", then baseline will be overwritten and automatically set to "grp".}

\item{g:}{an \code{nsig}-dimensional vector containing group indicators/covariates for each sample.}

\item{minobs:}{minimum number of obs required to be in each logistic model.}

\item{pseudocounts:}{a number to be added to counts.}

\item{all:}{bool, if TRUE pseudocounts are added to all entries, if FALSE pseudocounts are added only to cases when either number of successes or number of failures (but not both) is 0.}

\item{center:}{bool, indicating whether to center \code{g}.}

\item{repara:}{bool, indicating whether to reparameterize \code{alpha} and \code{beta} so that their likelihoods can be factorized.}

\item{forcebin:}{bool, if TRUE don't allow for overdipersion. Defaults to TRUE if \code{nsig=1}.}

\item{lm.approx:}{bool, indicating whether a WLS alternative should be used.}

\item{disp:}{a string, can be either "add" or "mult", indicates which type of overdispersion is assumed when \code{lm.approx=TRUE}.}

\item{shape.eff:}{bool, indicating whether to consider only shape effects (TRUE) or not (FALSE)}

\item{cxx:}{bool, indicating whether to use c++ code (faster) (TRUE) or R code (FALSE)}

\item{maxlogLR:}{a positive number, defaults to NULL, if \code{maxlogLR} is provided as a positive number, the function returns this number as \code{logLR} when \code{logLR} is infinite.}

\item{smoothing:}{bool, indicating whether to apply \pkg{ashr} to smooth the signal (TRUE) or not (FALSE); if \code{smoothing==FALSE} then reverse is set to FALSE; this option is only used when inferring shared pi-s.}

\item{cyclespin:}{bool, indicating whether to use cyclespin (i.e., TI table) (TRUE) or not (i.e., haar aggregate) (FALSE). If \code{cyclespin}==FALSE then reverse is set to FALSE because reversing wavelet is not implemented here.}

\item{reverse:}{bool, indicating whether to reverse wavelet (TRUE) or not.}

\item{set.fitted.g:}{a list of \code{J+1} mixture of normal models fitted using \pkg{ashr}, \code{J=log2(n)}.}

\item{set.fitted.g.intercept:}{a list of \code{J} mixture of normal models fitted using \pkg{ashr} on the intercept, \code{J=log2(n)}.}

\item{get.fitted.g:}{bool, indicating whether to save \code{fitted.g}.}

\item{listy:}{a list of elements \code{y},\code{y.rate},\code{intervals}; if \code{listy} is not NULL, then \code{y} and \code{y.rate} are forced to \code{listy$y} and \code{listy$y.rate} respectively; this option is used when inferring shared pi-s.}

\item{verbose:}{bool, defaults to FALSE, if TRUE \code{\link{multiseq}} also outputs \code{logLR$scales} (scales contains (part of) \pkg{ashr} output for each scale), \code{fitted.g}, and \code{fitted.g.intercept}.}

\item{ashparam:}{a list of parameters to be passed to \code{ash}; default values are set by function \code{\link{setAshParam}}.}
}
\value{
\code{multiseq} returns an object of \code{\link[base]{class}} "multiseq", a list with the following elements (or a simplified list if \code{verbose=FALSE} or \code{smoothing=FALSE}) \cr
\item{baseline.mean}{an \code{nsig}-vector with the posterior mean of baseline log(intensity)}
\item{baseline.var}{an \code{nsig}-vector with the posterior baseline variance}
\item{effect.mean}{an \code{nsig}-vector with the posterior effect mean}
\item{effect.var}{an \code{nsig}-vector with the posterior effect variance}
\item{logLR}{a list with elements \code{value} specifying the log likelihood ratio, \code{scales} a \code{J+1} vector specifying the logLR at each scale, \code{isfinite} bool specifying if the log likelihood ratio is finite}
\item{fitted.g}{a list of \code{J+1} mixture of normal models fitted using \pkg{ashr}, \code{J=log2(n)}}
\item{fitted.g.intercept}{a list of \code{J} mixture of normal models fitted using \pkg{ashr} on the intercept, \code{J=log2(n)}}
}
\description{
Fits the model \code{x}_{ib} \sim Poi(\lambda_{ib}) where $log(\lambda_{ib}) = \alpha_b + g_i \beta_b$.
where takes a series of Poisson count signals \code{x}, with data on different samples in each row, and smooths all simultaneously using a multiscale Poisson model. Optionally, it estimates the "effect" of a covariate \code{g}.
Estimates are all on the log intensity scale 
Parameters \code{minobs}, \code{pseudocounts}, \code{all}, \code{center}, \code{repara}, \code{forcebin}, \code{lm.approx}, and \code{disp} are passed to \code{\link{glm.approx}}. The list \code{ashparam} specifies a list of parameters to be passed to \code{ash}.
}
\examples{
#load data contained in dat
data(dat, package="multiseq")
res <- multiseq(x=dat$x, g=dat$g, minobs=1, lm.approx=FALSE, read.depth=dat$read.depth)
}

