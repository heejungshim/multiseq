% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiseq.R
\name{multiseq}
\alias{multiseq}
\title{Estimate and test for differences (or associations) in the high-throughput sequencing data (count data) 
across samples using the methods described in Shim et al., 2021.}
\usage{
multiseq(
  x = NULL,
  g = NULL,
  read.depth = NULL,
  reflect = FALSE,
  baseline = "inter",
  minobs = 1,
  pseudocounts = 0.5,
  all = FALSE,
  center = FALSE,
  repara = TRUE,
  forcebin = FALSE,
  lm.approx = TRUE,
  disp = "add",
  overall.effect = NULL,
  overall.loglr = NULL,
  cxx = TRUE,
  cyclespin = TRUE,
  reverse = TRUE,
  maxlogLR = NULL,
  verbose = FALSE
)
}
\arguments{
\item{x:}{a matrix of \code{nsig} by \code{n} counts where \code{n} is often a power of 2.}

\item{read.depth:}{an \code{nsig}-dimensional vector containing the total number of reads for each sample (used to test for association with the total intensity); defaults to NULL.}

\item{reflect:}{bool, if TRUE signal is reflected, if FALSE signal is not reflected. Default is FALSE. Defaults to TRUE if n is not power of 2. See \code{\link{reflectSignal}} for details.}

\item{baseline:}{a string, can be "inter" or "grp" or a number. Uses intercept \code{g=0} as baseline ("inter") or the group with the smallest \code{g} as baseline ("grp") or specifies value of \code{g} that should be baseline (number). If center==FALSE and baseline=="inter", then baseline will be overwritten and automatically set to "grp".}

\item{g:}{an \code{nsig}-dimensional vector containing group indicators/covariates for each sample.}

\item{overall.loglr:}{a positive number, defaults to NULL, if \code{overall.loglr} is provided as a positive number, the function uses \code{overall.loglr} as a log likelihood ratio for overall expression (top scale) when computing the test statistics. This option is useful when a user wants to incorporate the output from other software into multiseq.}

\item{overall.effect:}{a 2-dimensional vector, defaults to NULL, if \code{overall.effect} is provided as a 2-dimensional vector, the function uses the first and second elements of \code{overall.effect} as posterior mean and variance, respectively, for the effect on overall expression (top scale). This option is useful when a user wants to incorporate the output from other software into multiseq.}

\item{minobs:}{minimum number of obs required to be in each logistic model.}

\item{pseudocounts:}{a number to be added to counts.}

\item{all:}{bool, if TRUE pseudocounts are added to all entries, if FALSE pseudocounts are added only to cases when either number of successes or number of failures (but not both) is 0.}

\item{center:}{bool, indicating whether to center \code{g}.}

\item{repara:}{bool, indicating whether to reparameterize \code{alpha} and \code{beta} so that their likelihoods can be factorized.}

\item{forcebin:}{bool, if TRUE don't allow for overdipersion. Defaults to TRUE if \code{nsig=1}.}

\item{lm.approx:}{bool, indicating whether a WLS alternative should be used.}

\item{disp:}{a string, can be either "add" or "mult", indicates which type of overdispersion is assumed when \code{lm.approx=TRUE}.}

\item{cxx:}{bool, indicating whether to use c++ code (faster) (TRUE) or R code (FALSE)}

\item{maxlogLR:}{a positive number, defaults to NULL, if \code{maxlogLR} is provided as a positive number, the function returns this number as \code{logLR} when \code{logLR} is infinite.}

\item{cyclespin:}{bool, indicating whether to use cyclespin (i.e., TI table) (TRUE) or not (i.e., haar aggregate) (FALSE). If \code{cyclespin}==FALSE then reverse is set to FALSE because reversing wavelet is not implemented here.}

\item{reverse:}{bool, indicating whether to reverse wavelet (TRUE) or not.}

\item{verbose:}{bool, defaults to FALSE, if TRUE \code{\link{multiseq}} also outputs \code{logLR$scales} (scales contains (part of) \pkg{ashr} output for each scale), \code{fitted.g}, and \code{fitted.g.intercept}.}
}
\value{
\code{multiseq} returns an object of \code{\link[base]{class}} "multiseq", a list with the following elements (or a simplified list if \code{verbose=FALSE}) \cr
\item{baseline.mean}{an \code{n}-vector with the posterior mean of baseline log(intensity)}
\item{baseline.var}{an \code{n}-vector with the posterior baseline variance}
\item{effect.mean}{an \code{n}-vector with the posterior effect mean}
\item{effect.var}{an \code{n}-vector with the posterior effect variance}
\item{logLR}{a list with elements \code{value} specifying the log likelihood ratio, \code{scales} a \code{J+1} vector specifying the logLR at each scale, \code{isfinite} bool specifying if the log likelihood ratio is finite}
\item{fitted.g}{a list of \code{J+1} mixture of normal models fitted using \pkg{ashr}, \code{J=log2(n)}}
\item{fitted.g.intercept}{a list of \code{J} mixture of normal models fitted using \pkg{ashr} on the intercept, \code{J=log2(n)}}
}
\description{
This function takes a series of Poisson count data \code{x}, with data on different samples in each row, 
and a covariate (e.g., group indicator) \code{g}. Then, this function uses multi-scale Poisson process approaches 
1) to estimate the "effect" of the covariate \code{g} on the count data (in log scale; i.e., the difference in log-intensity 
between groups of samples) and 2) to test for association of the covariate \code{g} with the count data. The function 
returns 1) posterior mean and variance for the effect size and 2) test statistic (logLR) to measure the association signal. 
It also returns posterior mean and variance for the baseline signal. If `\code{g} == NULL`, this function only computes 
posterior and variance for the baseline signal. 

Parameters \code{minobs}, \code{pseudocounts}, \code{all}, \code{center}, \code{repara}, \code{forcebin}, \code{lm.approx}, 
and \code{disp} are passed to \code{\link{glm.approx}}.
}
\examples{
#load data contained in chr17.10160989.10162012.DNase.seq
data(chr17.10160989.10162012.DNase.seq, package="multiseq")
res <- multiseq(x=chr17.10160989.10162012.DNase.seq$x, g=chr17.10160989.10162012.DNase.seq$g)
}
